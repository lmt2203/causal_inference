---
title: "CausalImpact"
author: "Linh Tran"
date: "5/10/2021"
output: html_document
---

```{r setup, include=FALSE}
library(tidyverse)
library(bsts)
library(CausalImpact)
```


* What does the package `CausalImpact` do? - Estimate causal effect of a designed intervention on a time series. E.g.: How many additional daily clicks generated by an advertising campaign? or when randomized experiment is not available.\

* How does it work?
+ Given a response time series (e.g clicks) and a set of control time series (e.g clicks in non-affected markets or clicks on the other sites), the package construct a Bayesian structural time-series model. 
+ Model then used to predict the counterfactual i.e. how the response metric would have evolved after the intervention if the intervention had never occured. 

* Assumptions:
+ There is a set control time series that were *themselves not affected by the intervention*
+ Relationship between covariates and treated time series as established during pre-period remains stable through out the post-period. | Covariates are not affected by the intervention. 

* Given a response time series and a set of control time series, the function constructs a time-series model, performs posterior inference on the counterfactual, and returns a `CausalImpact` object


# Example dataset

Create a simple dataset contains a response variable `y` and a predictor `x1`. The example data has 100 observations. We create an intervention effect by lifting the response variable by 10 units after timepoint 71.

```{r}
set.seed(1)
x1 <- 100 + arima.sim(model = list(ar = 0.999), n = 100)
y <- 1.2 * x1 + rnorm(100)
y[71:100] <- y[71:100] + 10
data <- cbind(y, x1)

dim(data)
head(data)

#visualization
plot(data)
matplot(data, type = "l")

```


# Running an analysis

To estimate a causal effect, we begin by specifying which period in the data should be used for training the model (pre-intervention period) and which period for computing a counterfactual prediction (post-intervention period)

```{r}
pre.period <- c(1,70)  #time points 1 - 70 will be used for training
post.period <- c(71,100) #timepoints 71-100 will be used for computing predictions
```

```{r}
impact <- CausalImpact(data, pre.period, post.period )
impact

```

# Plotting the results

```{r}
plot(impact)
```

* The 1st panel show the data and a counterfactual prediction for the post-treatment period.
* The 2nd panel shows the **difference** between observed data and counterfactual predictions => pointwise causal effect
* The 3rd panel adds up the pointwise contributions from the 2nd panel, resulting in a plot of the cumulative effect of the intervention. 

# Working with Dates and Times

```{r}
time.points <- seq.Date(as.Date("2014-01-01"), by = 1, length.out = 100) #100 day starting from 2014_01_01
data <- zoo(cbind(y, x1), time.points)


head(data)

# specify the pre-period and post-period in terms of time points rather than indices:

pre.period <- as.Date(c("2014-01-01", "2014-03-11"))
post.period <- as.Date(c("2014-03-12", "2014-04-10"))

# results

impact <- CausalImpact(data, pre.period , post.period)

plot(impact)

summary(impact)

# estimated average causal effect of treatment was 10.5 
# observed an average value of 99 but would have expected an average value of only 89
# 95% posterial interval of the average effect is [9.8, 11]. Since this excludes 0, we can reject the null hypothesis and conclude that the intervention had a causal effect on the response variable
# assuming x1 was not affected by intervention itself

impact$summary
summary(impact, "report")
```

* Average = average (across time) during the post intervention period (i.e. 71-100)
* Cumulative = sums up individual timepoints, which is useful perspective if the response variable represents a flow quantity (e.g. queries, clicks, visits, installs, sales, revenue) rather than a stock quantity (e.g number of users)

# Adjusting the model

There are several options that allow us to gain a litte more control over this process. These options are passed into `model.args` as individual list elements:

```{r}

impact <- CausalImpact(data, pre.period, post.period,
                       model.args = list(niter = 5000, nseasons = 7))

```

* Available options:
+ `niter`: number of MCMC samples to draw. More sample more accurate inferences (default = 1000)
+ `standardize.data`: whether to standardize all columns of the data using moments estimated from the pre-intervention period before fitting the model (default = TRUE)
+ `nseasons` = period of the seasonal components. In order to include a seasonal component, set this to a whole number greater than 1. E.g. if the data represent daily obs, use 7 for a day-of-week component. To specify multiple seasonal components, use bsts to specify the model directly, then pass the fitted model in as bsts.model.(default = 1, which means no seasonal component is used)
+ `season.duration` = number of data points each season spans. 
+ `dynamic.regression` = whether to include time-varying regression coefficients. In combination with a time-varying local trend or even a time-varying local level, this often leads to overspecification, in which ase a static regression is safer. 

# Using a custom model
We can use the `bsts` package to specify our own model. This provides the greatest degree of flexibility

```{r}
post.period <- c(71, 100)
post.period.response <- y[post.period[1] : post.period[2]] #actual observed response

y[post.period[1] : post.period[2]] <- NA #set the observed data in the post-treatment period to NA. 

```

Next, set up and estimate a time-series model using `bsts`

```{r}
ss <- AddLocalLevel(list(), y)
bsts.model <- bsts(y ~ x1, ss, niter = 1000)
```


Difference between predicte response (stored in bsts.model) and actual observed response (stored in post.period.response)

```{r}
impact <- CausalImpact(bsts.model = bsts.model,
                       post.period.response = post.period.response)


plot(impact)
summary(impact)
summary(impact, "report")
```


# Some other settings

We can plot the posterior probability of each predictor being included in the model using:

```{r}
plot(impact$model$bsts.model, "coefficients")
```

